/*
* The robot plans a trip from home to the east part of the table
* and executes it.
*/ 
System workinroom  
mqttBroker "localhost" : 1883   
   
Dispatch modelChange  : modelChange( TARGET, VALUE )   
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )

Dispatch onestep       : onestep(DURATION)  
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Dispatch execButlerPlan: execButlerPlan( ACTION )

Dispatch prepare       : prepare(ARG)
Dispatch clear         : clear(ARG)
Dispatch add           : add(ARG)

Dispatch showFridgeState	: showFridgeState() // per lo stato del frigo
Dispatch showTableState		: showTableState() // per lo stato del tavolo
Dispatch isAvailable		: isAvalaible(CODE) // per il controllo presenza cibo nel frigo

Dispatch moveButlerTo  : moveButlerTo(X,Y,D) 
Dispatch goalReached   : goalReached(V)  	//V=ok | ko

Dispatch startTask     : startTask(T)		//T = fridge, table, pantry, dishwasher
Dispatch taskDone      : taskDone(V)  	    //V= ... 
Dispatch targetReached : targetReached(V)  	//V=ok | ko

Dispatch robotCmd      : robotCmd( CMD )	

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 
Event  stopAppl       : stopAppl( CMD )  
Event  reactivateAppl : reactivateAppl( CMD )  
 
/*
 * 
 */ 
 
Context ctxWorkInRoom     ip [host="localhost" port=8038]   -mqtt 
Context ctxDummyForMind   ip [host="otherhost" port=8035]   -mqtt 

ExternalQActor resourcemodel context ctxDummyForMind 
ExternalQActor onestepahead  context ctxDummyForMind
ExternalQActor basicrobot    context ctxDummyForMind


QActor butlermind context ctxWorkInRoom{     
["var ButlerStarted = false"]
	State s0 initial {	
		println("&&&  butlermind STARTED ")		 
  	}
  	Transition t0  
  		whenMsg prepare  -> doprepare
   	
   	State doprepare{
  		println("&&&  butlermind doprepare")
  		forward butlerplanexecutor -m execButlerPlan : execButlerPlan(prepare)
  	}
  	Transition t0  whenMsg targetReached -> afterPrepare
     	
 	State afterPrepare{
 		println("&&&  butlermind afterPrepare")
 	}  	
  	Transition t0  
     		whenMsg clear   -> doclear
    		whenMsg add     -> doadd
   	
   	State doadd{
  		println("&&&  butlermind doadd")
  		/*
  		 * Controllo della presenza del cibo è già stato effettuato con successo se 
  		 * sono arrivato qui, eseguo il ritiro dal frigo
  		 */
  		forward butlerplanexecutor -m execButlerPlan : execButlerPlan(add)
  	}
  	Transition t0  whenMsg targetReached -> afterPrepare
    	
   	State doclear{
  		println("&&&  butlermind doclear")
  		// cambiare in clear compreso il food
  		forward butlerplanexecutor -m execButlerPlan : execButlerPlan(clearnofood)
  	}
  	Goto s0


}	


QActor butlerplanexecutor context ctxWorkInRoom{   
["
var PlanCompleted = false
var CurTarget     = \"home\"
var CurDirection  = \"south\"
"]
	State s0 initial {	
 		solve( consult(  "butlerplansapriori.pl"  ) ) 
  	}
  	Goto doWork
  	
  	State doWork{
  		println("&&&  butlerplanexecutor doWork")	
  	}
  	Transition t0 whenMsg execButlerPlan -> doButlerPlan

  	State doButlerPlan{
  		["var action =\"\" "]
  		onMsg( execButlerPlan : execButlerPlan(ACTION) ){
  			["action = payloadArg(0)"]
 			println("&&&  butlerplanexecutor execButlerPlan $action ")		 			
  			solve( storePlan( "$action"  ) )  			
  		}
  	}
  	Goto execButlerPlan
  	
  	State execButlerPlan{
  		solve( consume( A,X,Y,D ) )
  		ifSolved{
["
CurTarget    = getCurSol(\"A\").toString()
CurDirection = getCurSol(\"D\").toString()
val Target = \"Target=\" + CurTarget +  \" X=\" + getCurSol(\"X\") + \" Y=\" + getCurSol(\"Y\") + \" DIRECTION=\" + getCurSol(\"D\")  
"]
  			println( "consume( $Target )"  ) 
   			forward workerinroom -m moveButlerTo : moveButlerTo(#X,#Y,#D) 
  		}else{ ["PlanCompleted = true"] }
  	}
  	Goto planExecuted if "PlanCompleted" else waitEndOfButlerPlanMove
  	
  	State waitEndOfButlerPlanMove{}
  	Transition t0 whenMsg goalReached -> doTheButlerJob

  	State doTheButlerJob{
		["val ButlerDirection = itunibo.planner.moveUtils.getDirection(myself)"]
   		println("butlerplanexecutor has reached $CurTarget/direction=$CurDirection, ButlerDirection=$ButlerDirection" ) 
   		if "CurTarget==\"table\"" { println("butlerplanexecutor works on the table " ) }
  		//Rotate the butler to perform the job
  		run itunibo.applUtil.applUtil.changeDirection( myself, CurDirection )
  		forward  butlermind -m targetReached : targetReached(ok)  	
  		run itunibo.planner.moveUtils.showCurrentRobotState()
  		delay 2000
  		//solve( dialog(F) )		//wait after goalReached
  	}
  	Goto execButlerPlan
  	
  	State planExecuted{
  		["PlanCompleted = false"]		//reset to redo
  	}
  	Goto doWork
  	

}


/* 
 * =============================================
 * workerinroom
 * =============================================
 */
QActor workerinroom context ctxWorkInRoom{     
["
var mapEmpty    = false
val mapname     = \"roomMbotWithTable\" //yyy \"roomMapWithTable\"

var Curmove     = \"\" 
var curmoveIsForward = false 

//REAL ROBOT
//var StepTime   = 1000 	 
//var PauseTime  = 500 

//VIRTUAL ROBOT
var StepTime   = 327	//for virtual // modificato era a 330
var PauseTime  = 500

var PauseTimeL  = PauseTime.toLong()

var timePreStep = 1L // per calcolo time backstep
var crashCounter = 0 // per riprovare a muoversi avanti supponendo ostacolo mobile
var timeBack = -1 // tempo di backstep

"]	 
	State s0 initial {	    
	    solve( consult("moves.pl")	 )
		run itunibo.coap.client.resourceObserverCoapClient.create( "coap://localhost:5683/resourcemodel" )
 		run itunibo.planner.plannerUtil.initAI()
  		run itunibo.planner.moveUtils.loadRoomMap( myself, mapname )	
  		run itunibo.planner.moveUtils.showCurrentRobotState()
	 	["	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  "]
	 	forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)   
	 	println("&&&  workerinroom STARTED")	
 	}  
	Transition t0 whenMsg moveButlerTo -> setGoalAndDo
  
  	State setGoalAndDo{
  		onMsg( moveButlerTo : moveButlerTo(X,Y,D) ) {
  			printCurrentMessage
  			["storeCurrentMessageForReply()"]  	//TODO: introduce a qak operation
  			run itunibo.planner.plannerUtil.setGoal(payloadArg(0),payloadArg(1))
  			run itunibo.planner.moveUtils.doPlan( myself )
  		}
  	}
  	Goto executePlannedActions   
  
	State executePlannedActions{ 
		//solve( showMoves ) 
		solve( retract( move(M) ) ) 
		ifSolved {  
			["Curmove = getCurSol(\"M\").toString() 
              curmoveIsForward=(Curmove == \"w\")
	        "]
		} else { ["Curmove = \"\"; curmoveIsForward=false"]  }  
		//println("executePlannedActions doing $Curmove")
 	}
	Goto checkAndDoAction  if "(Curmove.length>0) " else goalOk 

 	State goalOk{		  
 		//run itunibo.planner.moveUtils.showCurrentRobotState()
	 	["	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  "]
	 	forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)   
	 	["replyToCaller(\"goalReached\", \"goalReached(ok)\")"]  //TODO: introduce a qak operation
	}
	Transition t0 whenMsg moveButlerTo -> setGoalAndDo
  	
 	//Execute the move if it is a rotation or halt
	State checkAndDoAction{	 }
	Goto doForwardMove if "curmoveIsForward" else doTheMove
	  
	State doTheMove{
 		run itunibo.planner.moveUtils.rotate(myself, Curmove, PauseTime) //modifies also the planner state 		 
  	}
	Goto executePlannedActions 
	
 	State doForwardMove{
 		delayVar PauseTimeL  //Otherwise is too fast, even with remote interaction
 		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime) //forwards to onestepahead
		["timePreStep = System.currentTimeMillis()"]
	} 
	Transition t0   whenEvent stopAppl -> handleStopAppl
					whenMsg stepOk     -> handleStepOk   
					whenMsg stepFail   -> hadleStepFail 	
    	
    	
   State handleStopAppl{
    	println("APPLICATION STOPPED. Waiting for a reactivate")
    } 
    Transition t0  whenEvent reactivateAppl -> handleReactivateAppl
    
    State handleReactivateAppl{
    	println("APPLICATION RESUMED")
    } 
	Transition t0   whenMsg stepOk   -> handleStepOk   
					whenMsg stepFail -> hadleStepFail 	
    
	State handleStepOk{
 		run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
 		["crashCounter = 0"] // o non viene resettato in caso di ostacolo mobile
	}
	Goto executePlannedActions
	
	/* We could reach this state since the robot moves are not precise enough */
 	State hadleStepFail{
 		if "crashCounter == 0"{
 			/* 
 		 	*  Cerco di calcolare il tempo di backstep perfetto per evitare successive 
 		 	*  collisioni, chiaramente è soggetto al ritardo variabile dovuto alla 
 		 	*  computazione e ai messaggi, non va granché bene
 		 	*/
			println("timeBack fatto da noi")
 			["timeBack = (System.currentTimeMillis() - timePreStep - 45).toInt()"]
 			println("timeBack = $timeBack")
			
			/*
 			onMsg(stepFail : stepFail(Obs, Time)){
 				["timeBack = payloadArg(1).toString().toInt()"]
 				println("timeBack col payload")
 				println("timeBack = $timeBack")
 			}
 			*/
 		}
 		
 		["crashCounter++"]
 		// backstep senza usare delay che non accetta variabili
		run itunibo.planner.moveUtils.backToCompensate(myself, timeBack, 0)
 		
 		/*
 		 * Valutare la possibilità di aggiungere un altro stato per evitare
 		 * di avere tutto sto bordello con l'if, tipo handleStepFail aumenta
 		 * il counter e un altro stato per rifare il plan e risettare il 
 		 * counter a 0
 		 */
 		if "(crashCounter > 2)"{ // mettere in modo da sbattere max 2 volte
			println("Static obstacle found!")
			["val ButlerDirection = itunibo.planner.moveUtils.getDirection(myself)"]
			println("ButlerDirection = $ButlerDirection")
		
			println("Updating map with the found static obstacle")
			run itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
			println("New map")
			run itunibo.planner.moveUtils.showCurrentRobotState()
		
			println("Updating plan")
			solve( retractall( move(_) ))
			run itunibo.planner.moveUtils.doPlan(myself)

			["crashCounter = 0"]
		}
		else{
			println("Found obstacle, supposedly a moving one")
			["var timesLeft = 3 - crashCounter"] // da modificare per match con lo sbattere max 2 volte
			println("Trying to move ahead other $timesLeft times")
			
			/*
			 * Ho bisogno di riporre nel kb l'ultima mossa consumata (per forza una w)
			 * altrimenti è come se andassimo avanti. Due modi:
			 * - asserta per rimettere la mossa in cima e farla consumare per prima
			 * - retractall e poi doPlan, tanto non ho ancora posto la X sulla mappa,
			 *   il piano sarà ricalcolato uguale
			 */
			solve( asserta(move(w)) )
		}
	}
	Goto executePlannedActions
}

// chiaramente da spostare in un altro qak, contesto diverso
QActor fridge context ctxWorkInRoom{
	State s0 initial{
		solve(consult("fridgeInit.pl"))
		println("&&&  fridge starting, initial state as follows")
		solve(showFridgeState)
	}
	Goto waitCmd
	
	State waitCmd{
		println("&&&  fridge waiting for command")
	}
	Transition t0 whenMsg prepare -> prepareTask
				  whenMsg add -> addTask
				  whenMsg showFridgeState -> showTask
				  whenMsg isAvailable -> checkAvailability
				  
	State prepareTask{
		solve(consult("prepareFoodList.pl"))
		println("&&&  fridge received prepare, handing over food")
		solve(prepareFood)
		println("&&&  fridge state modified, now as follows")
		solve(showFridgeState)
	}
	Goto waitCmd
	
	State addTask{
		["var Code =\"\" "] // sono costretto all'iniziale maiuscola o non posso usarlo come argomento di un messaggio
		onMsg(add : add(C)){
			["Code = payloadArg(0)"]
			println("&&& fridge received add, checking availability of food with code $Code")
			solve(isThere("$Code"))
			ifSolved{
				solve(get("$Code",1)) // per il momento la add prende sempre 1 quantità
				ifSolved{
					println("Add possibile, fridge informa RBR")
					/* 
					 * Forward alla mind di un messaggio di add, dato che quello ricevuto qui
					 * dal frigo è stato inviato dal frontend e voglio che il robot si muova 
					 * solo se il cibo è disponibile
					 * Seems like sta cosa andrà cambiata e si dovrà passare dal frontend al
					 * robot e solo poi qui al frigo
					 * Non ha importanza girare il foodCode al robot
					 */
					forward butlermind -m add : add()
					// girare al centralstateserver l'add per aggiornamento stato tavolo
					forward centralstateserver -m add : add($Code)
				}else{
					println("Add impossibile, quantita' insufficiente nel frigo")
					/*
					 * Se il check fallisce il robot in quanto intelligente non compie la 
					 * add -> qui invio solo il warning al frontend
					 * Seems like sta cosa andrà cambiata e si dovrà passare dal frontend al
					 * robot e solo poi qui al frigo
					 */
					 forward resourcemodel -m modelUpdate : modelUpdate(fridge, addImpossibleWarning )
				}
			}else{
				println("Add impossibile, code inesistente o cibo terminato")
				forward resourcemodel -m modelUpdate : modelUpdate(fridge, addImpossibleWarning )
			}
		}
	}
	Goto waitCmd
	
	State showTask{
		println("&&&  fridge received showFridgeState, executing")
		solve(showFridgeState)
		// invio al frontend dello stato, da sostituire con invio coap?
		solve(getFridgeState(L))
		ifSolved{
			/* 
			 * Porre il parsing in un metodo utility, tanto è lo stesso per tutti
			 * Parsing in questo modo perché il resto è lato frontend
			 */
			["
		val str1 = getCurSol(\"L\").toString()
		val str2 = str1.replace(\"],[\",\"@\")
		val str3 = str2.replace(\"[\",\"\'\")
		val str4 = str3.replace(\"]\",\"\'\")
		val FridgeStateString = str4.substring(1,str4.length-1)
			"]
  			println("fridgeStateString = \\n$FridgeStateString")
  			forward resourcemodel -m modelUpdate : modelUpdate(fridge, $FridgeStateString )
   		}else{
   			println("getFridgeState FAIL")
   		}
	}
	Goto waitCmd
	
	State checkAvailability{
		println("&&&  fridge received availability check, executing")
		["var code = \"\" "]
		onMsg(isAvailable : isAvailable(CODE)){
			["code = payloadArg(0)"]
			solve(isThereFood("$code"))
			ifSolved{
				println("Food available")
				forward resourcemodel -m modelUpdate : modelUpdate(fridge, foodAvailable )
			}else{
				println("Food not found")
				forward resourcemodel -m modelUpdate : modelUpdate(fridge, foodNotFound )
			}
		}
	}
	Goto waitCmd
	
}

/*
QActor fridgeuserdummy context ctxWorkInRoom{
	State s0 initial{
		println("fridgeUserDummy, invio prepare al frigo tra 10 secondi")
		delay 10000
		forward fridge -m prepare : prepare()
		
		println("fridgeUserDummy, invio add al frigo tra 10 secondi")
		delay 10000
		forward fridge -m add : add(d) // d01
		
		println("fridgeUserDummy, invio showFridgeState al frigo tra 10 secondi")
		delay 10000
		forward fridge -m showFridgeState : showFridgeState()
	}
}
*/

/*
 * Server centrale che gestisca gli stati degli enti non intelligenti 
 * Robe da ricordare:
 *    - per il momento non gestiamo i piatti ma non dovrebbe essere troppo diverso
 *      dai cibi
 *    - i cibi sul tavolo sono gli stessi che prendo dal frigo sulla prepare -> sfrutto
 *      lo stesso file
 *    - ad ogni richiesta dello stato del tavolo, prima di inviare lo stato al maitre (o 
 * 		dopo), simulare il consumo di una quantità randomica di cibo, una random per cibo 
 *		che vari da 0 a N, così alcuni cibi restano immutati (altrimenti creare un actor
 *		che autonomamente ogni delay x simuli consumazioni randomiche)
 *    - non si occupa di gestire il frigo che è una entità smart autonoma, maitre 
 *      chiede direttamente al frigo
 *    - lavastoviglie è libera finché non si fa la clear e clear è la fine del work,
 *      che senso ha gestirne lo stato?
 *    - Quando faccio la add non passo dalla credenza -> non prendo altri piatti,
 *      che senso ha gestire lo stato della credenza e dei piatti in generale se
 *      tanto questi sono messi nel tavolo, mai utilizzati esplicitamente e messi
 *      solo alla fine dell'applicazione nella lavastoviglie?
 */
QActor centralstateserver context ctxWorkInRoom{
	State s0 initial{
		println("&&& centralStateServer starting")
		solve(consult("prepareFoodList.pl")) // motivazione nel commento qui sopra
		// tentativo gestione piatti (tableware)
		solve(consult("pantryInit.pl"))
		solve(consult("prepareTablewareList.pl"))
	}
	Goto waitCmd
	
	State waitCmd{
		println("&&& centralStateServer waiting for command")
	}
	Transition t0 whenMsg showTableState -> showTableTask
				  whenMsg prepare -> prepareTable
				  whenMsg add -> addTable
				  whenMsg clear -> clearTable
				  // aggiungere le show del resto se richieste
				
	// modificare tutte le show perché inviino gli output al frontend  
	State showTableTask{
		println("&&& centralStateServer showTableState")
		solve(showFoodTableState)
		solve(getFoodTableState(L))
		ifSolved{
			/* 
			 * Porre il parsing in un metodo utility, tanto è lo stesso per tutti
			 * Parsing in questo modo perché il resto è lato frontend
			 */
			["
		val str1 = getCurSol(\"L\").toString()
		val str2 = str1.replace(\"],[\",\"@\")
		val str3 = str2.replace(\"[\",\"\'\")
		val str4 = str3.replace(\"]\",\"\'\")
		val FoodTableStateString = str4.substring(1,str4.length-1)
			"]
  			println("foodTableStateString = \\n$FoodTableStateString")
  			forward resourcemodel -m modelUpdate : modelUpdate(foodTable, $FoodTableStateString)
   		}else{
   			println("getFoodTableState FAIL")
   		}
   		// show piatti (tableware)
   		solve(showTablewareTableState)
		solve(getTablewareTableState(L))
		ifSolved{
			/* 
			 * Porre il parsing in un metodo utility, tanto è lo stesso per tutti
			 * Parsing in questo modo perché il resto è lato frontend
			 */
			["
		val str5 = getCurSol(\"L\").toString()
		val str6 = str5.replace(\"],[\",\"@\")
		val str7 = str6.replace(\"[\",\"\'\")
		val str8 = str7.replace(\"]\",\"\'\")
		val TablewareTableStateString = str8.substring(1,str8.length-1)
			"]
  			println("tablewareTableStateString = \\n$TablewareTableStateString")
  			forward resourcemodel -m modelUpdate : modelUpdate(tablewareTable, $TablewareTableStateString)
   		}else{
   			println("getTablewareTableState FAIL")
   		}
	}
	Goto randomConsumption
	
	State randomConsumption{
		println("&&& centralStateServer randomly consuming")
		solve(randomFoodConsumption)
		/*
		 * Anche qui sarebbe nice se la radomConsumption dei tableware fosse
		 * relativa ai cibi consumati -> ad esempio se consumo una bibita dovrò
		 * consumare un bicchiere ecc -> implementarlo lato prolog con un unico
		 * predicato randomConsumption?
		 */
		solve(randomTablewareConsumption)
		println("&&& centralStateServer randomConsumption executed, now table state as follows")
		solve(showFoodTableState)
		solve(showTablewareTableState)
	}
	Goto waitCmd
	
	State prepareTable{
		println("&&& centralStateServer prepareTable, now table state as follows")
		solve(assert(enabled(true))) // rende visibili i cibi e i piatti
		solve(prepareTableware) // non c'è l'attore pantry, gestisco qui il ritiro piatti
		solve(showFoodTableState)
		solve(showTablewareTableState)
	}
	Goto waitCmd
	
	State addTable{
		println("&&& centralStateServer updating tableState after add")
		["var code = \"\" "]
		onMsg(add : add(CODE)){
			["code = payloadArg(0)"]
			solve(addTable("$code",1))
		}
		println("&&& centralStateServer updated table, now table state as follows")
		solve(showFoodTableState)
		/*
		 * Sarebbe cool se alla add di un cibo si aggiungesse anche il
		 * corrispettivo tableware (anche se si tratta di una modifica alla
		 * richiesta del comportamento della add, dovendo così passare anche
		 * dalla pantry)
		 * In alternativa si può porre sul tavolo un numero gigante di tableware
		 * così non ci sarà mai da rifornire
		 */
	}
	Goto waitCmd
	
	State clearTable{
		println("&&& centralStateServer updating tableState after clear")
		/*
		 * Modificato da solve(retractAll(foodTable(F,C,N))) dato che è molto
		 * più pulito fare una retract(enabled(true))
		 * Inoltre ho bisogno che le info sugli item sul tavolo rimangano
		 * dato che devo riportare tali item nei rispettivi contenitori
		 * NB se devo effettivamente liberare il tavolo dai piatti dovrò 
		 * passare dalla pantry -> modifica a parte del comportamento
		 * richiesto alla clear -> è corretto?
		 */ 
		solve(retract(enabled(true)))
		// aggiungere la gestione della riconsegna cibo
		/*
		 * Riconsegna tableware è semplice dato che lo stato della pantry è
		 * mantenuto da questo stesso attore, ma non posso fare la clear
		 * del cibo allo stesso modo -> ci dovrà essere uno scambio di 
		 * messaggi verso il frigo (probabilmente implementabile come
		 * ottenimento della stringa di stato del cibo, passaggio della stessa
		 * al frigo, parsing lato kotlin di ogni cibo e put nel frigo dando
		 * come argomento ognuno dei parametri ricavati)
		 */
		solve(clearTableware)
		println("&&& centralStateServer updated table, now table state as follows")
		solve(showFoodTableState)
	}
	Goto waitCmd
	
}

/* Commento per usare il frontend
 
QActor frontenddummy context ctxWorkInRoom{
	State s0 initial {
		println("&&&  frontendDummy start")
	}
	Goto sendPrepare
	
	State sendPrepare{
		println("&&&  frontenddummy will send prepare msg to butlermind in 5 seconds")
		delay 5000
		println("&&&  frontenddummy sends now prepare msg")
		forward butlermind -m prepare : prepare()
	}
	Goto sendPause
	
	State sendPause{
		println("&&&  frontenddummy will send pause event in 5 seconds")
		delay 5000
		println("&&&  frontenddummy sends now pause event")
		emit stopAppl : stopAppl()
	}
	Goto sendReactivate
	
	State sendReactivate{
		println("&&&  frontenddummy will send reactivate event in 5 seconds")
		delay 5000
		println("&&&  frontenddummy sends now reactivate event")
		emit reactivateAppl : reactivateAppl()
	}
	Goto sendAdd
	
	State sendAdd{
		println("&&&  frontenddummy will send add msg to addtask in 40 seconds")
		delay 40000
		println("&&&  frontenddummy sends now add msg")
		forward butlermind -m add : add(foodCode)
	}
	Goto sendClear
	
	State sendClear{
		println("&&&  frontenddummy will send clear msg to cleartask in 30 seconds")
		delay 30000
		println("&&&  frontenddummy sends now clear msg")
		forward butlermind -m clear : clear()
	}
	Goto workDone
	
	State workDone{
		println("&&&  frontenddummy workDone")
	}
	
}
*/
