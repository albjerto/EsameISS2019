System fridge
mqttBroker "localhost" : 1883  


Dispatch add			: add(ARG)
Dispatch get			: get(ARG)
Dispatch put         	: put(ARG)
Dispatch showState	: showState()
Dispatch isAvailable	:	isAvailable(ARG)
Dispatch yes			:	yes()
Dispatch no				: 	no()



Event modelcontent: modelcontent(CONTENT)

Dispatch remove			:	remove(ARG)


Context ctxFridge     ip [host="localhost" port=8038]   -mqtt 


//funziona senza proxy
QActor fridgecoap context ctxFridge{	
	/*
	 *fridge:
	 * ->get, <-put
	 * ->isAvailable, <-yes/<-no
	 * ->put, <-remove
	 */
	
	 ["val actor=this"]

	State s0 initial{
		solve(consult("fridgeInit.pl"))
		["itunibo.coap.server.CoapServerControl.create(actor,\"fridge\")"]
		println("&&&  coap fridge STARTED")
	}
	Goto waitCmd
	
	State waitCmd{
		println("&&&  fridge waiting for command")
	}
	
	Transition t0	 whenMsg put -> putTask
				 	 whenMsg showState -> showStateTask
				 	 whenMsg get -> getTask
				 	 whenMsg isAvailable -> checkTask

	
	
	State showStateTask{
		printCurrentMessage
		solve(getFridgeState(L))
		ifSolved{
			["
				val FridgeState = itunibo.prolog.prologUtils.parseFoodState(myself,\"L\")
			"]
			["itunibo.coap.server.CoapServerControl.coapRespond(FridgeState)"]
  			
   		}else{
   			println("getFridgeState FAIL")
   		}
	}Goto waitCmd
	
	
	
	State getTask{
		printCurrentMessage
		onMsg(get: get(ARG)){
			[" 
				val Food = payloadArg(0)
			"]
			
			solve(removeFoodList($Food))
			ifSolved {
				println("Food = $Food")
				["itunibo.coap.server.CoapServerControl.coapRespond(\"put($Food)\")"]
				["itunibo.coap.server.CoapServerControl.coapNotify()"]		
			} else {
				println("fridgeGet FAIL")
			}
		}
	}
	Goto waitCmd
	
	
	State putTask{
		onMsg(put: put(ARG)){
			printCurrentMessage
			[" val Food = payloadArg(0) "]
			solve(addFoodList("$Food"))
			ifSolved {
				["itunibo.coap.server.CoapServerControl.coapRespond(\"remove($Food)\")"]
				["itunibo.coap.server.CoapServerControl.coapNotify()"]		
			} else {
				println("fridgePut FAIL")
			}		
		}
	}Goto waitCmd
	
	State checkTask{
		onMsg(isAvailable: isAvailable(ARG)){
			printCurrentMessage
			[" val foodCode = payloadArg(0) "]
			solve(isThereFoodByCode("$foodCode"))
			ifSolved {
				["itunibo.coap.server.CoapServerControl.coapRespond(\"yes()\")"]
			} else {
				["itunibo.coap.server.CoapServerControl.coapRespond(\"no()\")"]
			}	
		}
	}Goto waitCmd
}




/* 

QActor serverproxy context ctxFridge{
	["val actor=this"]	
	State s0 initial{
		println("&&&  fridgeProxy starting")
		["itunibo.coap.server.CoapServerControl.create(actor,\"fridge\")"]	
		
	}Goto waitCmd
	
	State waitCmd{
		println("&&&  fridgeProxy waiting for command")
	}
	Transition t0  	whenMsg put -> putTask
				 	whenMsg showState -> showStateTask
				 	whenMsg get -> getTask
				 	whenMsg isAvailable -> checkAvailability
					whenEvent modelcontent -> modelcontentTask
	
	
	// se mando una put al frigo mi deve rispondere con una remove			
	State putTask{
			onMsg(put : put(C)){
				forward fridge -m put : put(C)   
		}
	}	  
	Transition t0  	whenMsg remove -> removeTask
	
	
	State removeTask{
		onMsg(remove : remove(C)){
			["val payload=payloadArg(0)"]
			["val responce=\"remove($payload)\""]
			["itunibo.coap.server.CoapServerControl.coapRespond(responce)"]
		}
	}
	Goto waitCmd
	
	
	// se mando una get al frigo mi deve rispondere con una put
	State getTask{
			onMsg(get : get(C)){
				forward fridge -m get : get(C)   
		}
	}	  
	Transition t0  	whenMsg put -> putTask				  
	
			
	State putTask{		
		onMsg(put : put(C)){
			["val payload=payloadArg(0)"]
			["val responce=\"put($payload)\""]
			["itunibo.coap.server.CoapServerControl.coapRespond(responce)"]
		}
	}		
	Goto waitCmd
			
	State checkAvailability{
		onMsg(isAvailable : isAvailable(C)){
				forward fridge -m isAvailable : isAvailable(C)   
		}	
	}  
	Transition t0  	
		whenMsg yes-> yesTask
		whenMsg no-> noTask		
		
	State yesTask{
		["val responce=\"yes\""]
		["itunibo.coap.server.CoapServerControl.coapRespond(responce)"]
		
	}  	
	Goto waitCmd
	
	
	State noTask{
		["val responce=\"no\""]
		["itunibo.coap.server.CoapServerControl.coapRespond(responce)"]
		
	}  	
	Goto waitCmd	
		
			
	State showStateTask{
		forward fridge -m showState : showState()
		["itunibo.coap.server.CoapServerControl.coapRespond(\"\")"]	
	}	  
	Goto waitCmd	
		  
	
	State modelcontentTask{
		onMsg(modelcontent : modelcontent(ARG)){
			["val responce=payloadArg(0)"]
			["itunibo.coap.server.CoapServerControl.coapNotify()"]
			["itunibo.coap.server.CoapServerControl.coapRespond(payloadArg(0))"]		
		}	
	}
	Goto waitCmd	  
}


QActor fridge context ctxFridge{	//<- il contesto?

	State s0 initial{
		solve(consult("fridgeInit.pl"))
		println("&&&  fridge STARTED")
	}
	Goto waitCmd
	
	State waitCmd{
		println("&&&  fridge waiting for command")
	}
	
	Transition t0	 whenMsg put -> putTask
				 	 whenMsg showState -> showStateTask
				 	 whenMsg get -> getTask
				 	 whenMsg isAvailable -> checkTask

	
	
	State showStateTask{
		printCurrentMessage
		//solve(showFridgeState)
		solve(getFridgeState(L))
		ifSolved{
			["
				val FridgeState = itunibo.prolog.prologUtils.parseFoodState(myself,\"L\")
			"]
  			emit  modelcontent: modelcontent(content( fridge( state( $FridgeState) ) ))
   		}else{
   			println("getFridgeState FAIL")
   		}
	}Goto waitCmd
	
	State getTask{
		printCurrentMessage
		onMsg(get: get(ARG)){
			[" 
				val Food = payloadArg(0)
			"]
			
			solve(removeFoodList($Food))
			ifSolved {
				println("Food = $Food")
				forward serverproxy -m put : put($Food)	
			} else {
				println("fridgeGet FAIL")
			}
		}
	}
	Goto showStateTask
	
	State putTask{
		onMsg(put: put(ARG)){
			printCurrentMessage
			[" val Food = payloadArg(0) "]
			solve(addFoodList("$Food"))
			ifSolved {
				forward serverproxy -m remove : remove($Food)
			} else {
				println("fridgePut FAIL")
			}		
		}
	}Goto showStateTask
	
	State checkTask{
		onMsg(isAvailable: isAvailable(ARG)){
			printCurrentMessage
			[" val foodCode = payloadArg(0) "]
			solve(isThereFoodByCode("$foodCode"))
			ifSolved {
				forward serverproxy -m yes : yes()
			} else {
				forward serverproxy -m no : no()
			}	
		}
	}Goto waitCmd
}

*/










