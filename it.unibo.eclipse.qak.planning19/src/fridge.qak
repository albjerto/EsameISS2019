System fridge
mqttBroker "localhost" : 1883  
Dispatch showFridgeState	: showFridgeState() // per lo stato del frigo
Dispatch showTableState		: showTableState() // per lo stato del tavolo
Dispatch isAvailable		: isAvalaible(CODE) // per il controllo presenza cibo nel frigo
Event    stateChanged    	: stateChanged()			//quando viene modificato lo stato del frigo

Dispatch prepare       : prepare(ARG)
Dispatch add           : add(ARG)




Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )  	//la risposta dell'attore frigo 


Context ctxFridge     ip [host="localhost" port=8038]   -mqtt 


QActor serverproxy context ctxFridge{
	["val actor=this"]	//se faccio this all'interno dello stato non mi prende l'attore ma l0 stato -.-
	State s0 initial{
		println("&&&  fridgeProxy starting")
		["itunibo.coap.server.CoapServerControl.create(actor,\"fridge\")"]	
		
	}Goto waitCmd
	
	State waitCmd{
		println("&&&  fridgeProxy waiting for command")
	}
	Transition t0 whenMsg prepare -> prepareTask
				  whenMsg add -> addTask
				  whenMsg showFridgeState -> showTask
				  whenMsg isAvailable -> checkAvailability
				  whenMsg  modelUpdate-> respondCoap
				  whenEvent stateChanged-> notifyCoap
			
			
	//SE ARRIVA UN MESSAGGIO PER IL FRIGO LO INOLTRO ALL'ATTORE VERO	  		  
	State prepareTask{
		forward fridge -m prepare : prepare()
	}		
	Goto waitCmd	  
			
	State addTask{
			onMsg(add : add(C)){
				forward fridge -m add : add(C)   
		}
	}	  
	Goto waitCmd			  
	
			
	State showTask{
		forward fridge -m showFridgeState : showFridgeState()
	}	  
	Goto waitCmd	
		  
	State checkAvailability{
		forward fridge -m isAvailable : isAvailable()
	}	  
	Goto waitCmd	
		  
	
	//SE ARRIVA UN MESSAGGIO DAL FRIGO LO INOLTRO AL SERVER COAP
	State respondCoap{
		onMsg(modelUpdate : modelUpdate(TARGET, VALUE)){
			println("&&&  serverproxy received model update")
			["itunibo.coap.server.CoapServerControl.coapRespond(payloadArg(1))"]
			
		}
	}  
	Goto waitCmd	
	
	
	State notifyCoap{
		["itunibo.coap.server.CoapServerControl.coapNotify()"]	
	}	
	Goto waitCmd	
}


QActor fridge context ctxFridge{
	State s0 initial{
		solve(consult("fridgeInit.pl"))
		println("&&&  fridge starting, initial state as follows")
		solve(showFridgeState)
	}
	Goto waitCmd
	
	State waitCmd{
		println("&&&  fridge waiting for command")
	}
	Transition t0 whenMsg prepare -> prepareTask
				  whenMsg add -> addTask
				  whenMsg showFridgeState -> showTask
				  whenMsg isAvailable -> checkAvailability
				  
	State prepareTask{
		solve(consult("prepareFoodList.pl"))
		println("&&&  fridge received prepare, handing over food")
		solve(prepareFood)
		println("&&&  fridge state modified, now as follows")
		solve(showFridgeState)
	}
	Goto waitCmd
	
	State addTask{
		["var Code =\"\" "] // sono costretto all'iniziale maiuscola o non posso usarlo come argomento di un messaggio
		onMsg(add : add(C)){
			["Code = payloadArg(0)"]
			solve(get("$Code",1)) // per il momento la add prende sempre 1 quantità
				ifSolved{
					println("Add possibile, fridge informa RBR")
					/* 
					 * Forward alla mind di un messaggio di add, dato che quello ricevuto qui
					 * dal frigo è stato inviato dal frontend(BUGIA) e voglio che il robot si muova 
					 * solo se il cibo è disponibile
					 * Seems like sta cosa andrà cambiata e si dovrà passare dal frontend al
					 * robot e solo poi qui al frigo
					 * Non ha importanza girare il foodCode al robot
					 */
					 emit stateChanged: stateChanged()
					forward serverproxy -m modelUpdate : modelUpdate(fridge, addCompleted)
					// girare al centralstateserver l'add per aggiornamento stato tavolo
					//forward centralstateserver -m add : add($Code)
				}else{
					println("Add impossibile, quantita' insufficiente nel frigo")
					/*
					 * Se il check fallisce il robot in quanto intelligente non compie la 
					 * add -> qui invio solo il warning al frontend
					 * Seems like sta cosa andrà cambiata e si dovrà passare dal frontend al
					 * robot e solo poi qui al frigo
					 */
					 forward serverproxy -m modelUpdate : modelUpdate(fridge, addImpossibleWarning )
				}
			}
	}
	Goto waitCmd
	
	State showTask{
		println("&&&  fridge received showFridgeState, executing")
		solve(showFridgeState)
		// invio al frontend dello stato, da sostituire con invio coap?
		solve(getFridgeState(L))
		ifSolved{
			/* 
			 * Porre il parsing in un metodo utility, tanto è lo stesso per tutti
			 * Parsing in questo modo perché il resto è lato frontend
			 */
			["
		val str1 = getCurSol(\"L\").toString()
		val str2 = str1.replace(\"],[\",\"@\")
		val str3 = str2.replace(\"[\",\"\'\")
		val str4 = str3.replace(\"]\",\"\'\")
		val FridgeStateString = str4.substring(1,str4.length-1)
			"]
  			println("fridgeStateString = \\n$FridgeStateString")
  			forward serverproxy -m modelUpdate : modelUpdate(fridge, $FridgeStateString )
   		}else{
   			println("getFridgeState FAIL")
   		}
	}
	Goto waitCmd
	
	State checkAvailability{
		println("&&&  fridge received availability check, executing")
		["var code = \"\" "]
		onMsg(isAvailable : isAvailable(CODE)){
			["code = payloadArg(0)"]
			solve(isThereFood("$code"))
			ifSolved{
				println("Food available")
				forward serverproxy -m modelUpdate : modelUpdate(fridge, foodAvailable )
			}else{
				println("Food not found")
				forward serverproxy -m modelUpdate : modelUpdate(fridge, foodNotFound )
			}
		}
	}
	Goto waitCmd
}